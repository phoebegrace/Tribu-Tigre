"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.list_events = void 0;
const zod_1 = require("zod");
const tool_1 = require("../../tool");
const util_1 = require("../../util");
const events_1 = require("../../../crashlytics/events");
const types_1 = require("../../../crashlytics/types");
const filters_1 = require("../../../crashlytics/filters");
function pruneThreads(sample) {
    var _a, _b, _c;
    if (((_a = sample.issue) === null || _a === void 0 ? void 0 : _a.errorType) === types_1.ErrorType.FATAL || ((_b = sample.issue) === null || _b === void 0 ? void 0 : _b.errorType) === types_1.ErrorType.ANR) {
        sample.threads = (_c = sample.threads) === null || _c === void 0 ? void 0 : _c.filter((t) => t.crashed || t.blamed);
    }
    return sample;
}
exports.list_events = (0, tool_1.tool)({
    name: "list_events",
    description: `Lists the most recent events matching the given filters.
      Can be used to fetch sample crashes and exceptions for an issue,
      which will include stack traces and other data useful for debugging.`,
    inputSchema: zod_1.z.object({
        appId: filters_1.ApplicationIdSchema,
        filter: filters_1.EventFilterSchema,
        pageSize: zod_1.z.number().describe("Number of rows to return").default(1),
    }),
    annotations: {
        title: "List Crashlytics Events",
        readOnlyHint: true,
    },
    _meta: {
        requiresAuth: true,
    },
}, async ({ appId, filter, pageSize }) => {
    if (!appId)
        return (0, util_1.mcpError)(`Must specify 'appId' parameter.`);
    if (!filter || !filter.issueId)
        return (0, util_1.mcpError)(`Must specify 'issue_id' parameter.`);
    const samples = await (0, events_1.listEvents)(appId, filter, pageSize);
    samples.events = samples.events.map((e) => pruneThreads(e));
    return (0, util_1.toContent)(samples);
});
